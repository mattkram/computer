<svg xmlns="http://www.w3.org/2000/svg" viewBox="-50 -50 300 300" width="400" height="400">

  <style>
  .circuit {
      fill: none;
      stroke: black;
      stroke-width: 3px;
  }
  .circuit-node {
      r: 8; // radius
      stroke: none;
      fill-opacity: 1;
      fill: black;
  }

  .node-label {
      font-family: "Arial";
      font-size: 10px;
      text-anchor: middle;
  }
  </style>

  <!-- The path that connects the nodes -->
  <path id="circuitPath" d="M 0,0 L 100,0 L 100,100 L 0,100 Z" class="circuit"/>

  <!-- Draggable corner nodes -->
  <circle class="circuit-node" cx="0" cy="0"/>
  <circle class="circuit-node" cx="100" cy="0"/>
  <circle class="circuit-node" cx="100" cy="100"/>
  <circle class="circuit-node" cx="0" cy="100"/>

  <!-- Coordinate display for each node -->
  <text class="node-label" x="0" y="-10">(0,0)</text>
  <text class="node-label" x="100" y="-10">(100,0)</text>
  <text class="node-label" x="100" y="115">(100,100)</text>
  <text class="node-label" x="0" y="115">(0,100)</text>

  <script type="text/javascript"><![CDATA[
    // Get all nodes and the path
    const nodes = [...document.getElementsByClassName('circuit-node')];
    const nodeLabels = [...document.getElementsByClassName('node-label')];
    const path = document.getElementById('circuitPath');

    // Variables to track the currently dragged element
    let selectedNode = null;
    let offset = { x: 0, y: 0 };

    // Make nodes draggable
    nodes.forEach((node, index) => {
      // Add cursor style
      node.style.cursor = 'move';

      // Mouse down event
      node.addEventListener('mousedown', (evt) => {
        selectedNode = { element: node, index: index };
        const CTM = node.ownerSVGElement.getScreenCTM();

        // Calculate offset
        offset.x = (evt.clientX - CTM.e) / CTM.a - parseFloat(node.getAttribute('cx'));
        offset.y = (evt.clientY - CTM.f) / CTM.d - parseFloat(node.getAttribute('cy'));

        // Visual feedback
        node.setAttribute('r', '10');
        node.setAttribute('fill-opacity', '1');

        evt.preventDefault();
      });
    });

    // Mouse move event (for dragging)
    document.addEventListener('mousemove', (evt) => {
      if (selectedNode) {
        evt.preventDefault();

        const CTM = selectedNode.element.ownerSVGElement.getScreenCTM();

        // Calculate new position
        const x = (evt.clientX - CTM.e) / CTM.a - offset.x;
        const y = (evt.clientY - CTM.f) / CTM.d - offset.y;

        // Update node position
        selectedNode.element.setAttribute('cx', x);
        selectedNode.element.setAttribute('cy', y);

        // Update coordinate text
        nodeLabels[selectedNode.index].setAttribute('x', x);
        nodeLabels[selectedNode.index].setAttribute('y', y > 50 ? y + 15 : y - 10);
        nodeLabels[selectedNode.index].textContent = `(${Math.round(x)},${Math.round(y)})`;

        // Update the path
        updatePath();
      }
    });

    // Mouse up event (for releasing)
    document.addEventListener('mouseup', () => {
      if (selectedNode) {
        // Reset visual feedback
        selectedNode.element.setAttribute('r', '8');
        selectedNode.element.setAttribute('fill-opacity', '0.7');
        selectedNode = null;
      }
    });

    // Update the path to connect all nodes
    function updatePath() {
      const pathData = nodes.map((node, index) => {
        const x = parseFloat(node.getAttribute('cx'));
        const y = parseFloat(node.getAttribute('cy'));
        return (index === 0 ? 'M ' : 'L ') + x + ',' + y;
      }).join(' ') + ' Z';

      path.setAttribute('d', pathData);
    }
  ]]></script>
</svg>
